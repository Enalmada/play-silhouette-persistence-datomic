package utils.persistence.datomic.daos

import com.mohiva.play.silhouette.api.{ AuthInfo, LoginInfo }
import com.mohiva.play.silhouette.impl.providers.{ OAuth1Info, OAuth2Info }
import com.mohiva.play.silhouette.persistence.daos.DelegableAuthInfoDAO
import datomisca.DatomicMapping._
import datomisca._
import datomiscadao.DB

import scala.collection.mutable
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.language.reflectiveCalls

/**
 * An implementation of the auth info DAO which stores the data in memory.
 *
 * This is not thread-safe implementation which should only be used for testing or development purpose.
 */
trait DatomicAuthInfoDAO[T <: AuthInfo] extends DelegableAuthInfoDAO[T] {

  /**
   * The data store for the auth info.
   */
  var data: mutable.HashMap[LoginInfo, T] = mutable.HashMap()

  /**
   * Finds the auth info which is linked with the specified login info.
   *
   * @param loginInfo The linked login info.
   * @return The retrieved auth info or None if no auth info could be retrieved for the given login info.
   */
  def find(loginInfo: LoginInfo): Future[Option[T]] = {
    Future.successful(data.get(loginInfo))
  }

  /**
   * Adds new auth info for the given login info.
   *
   * @param loginInfo The login info for which the auth info should be added.
   * @param authInfo  The auth info to add.
   * @return The added auth info.
   */
  def add(loginInfo: LoginInfo, authInfo: T): Future[T] = {
    data += (loginInfo -> authInfo)
    Future.successful(authInfo)
  }

  /**
   * Updates the auth info for the given login info.
   *
   * @param loginInfo The login info for which the auth info should be updated.
   * @param authInfo  The auth info to update.
   * @return The updated auth info.
   */
  def update(loginInfo: LoginInfo, authInfo: T): Future[T] = {
    data += (loginInfo -> authInfo)
    Future.successful(authInfo)
  }

  /**
   * Saves the auth info for the given login info.
   *
   * This method either adds the auth info if it doesn't exists or it updates the auth info
   * if it already exists.
   *
   * @param loginInfo The login info for which the auth info should be saved.
   * @param authInfo  The auth info to save.
   * @return The saved auth info.
   */
  def save(loginInfo: LoginInfo, authInfo: T): Future[T] = {
    find(loginInfo).flatMap {
      case Some(_) => update(loginInfo, authInfo)
      case None => add(loginInfo, authInfo)
    }
  }

  /**
   * Removes the auth info for the given login info.
   *
   * @param loginInfo The login info for which the auth info should be removed.
   * @return A future to wait for the process to be completed.
   */
  def remove(loginInfo: LoginInfo): Future[Unit] = {
    data -= loginInfo
    Future.successful(())
  }
}

object LoginInfoImpl extends DB[LoginInfo] {

  object Schema {

    object ns {
      val loginInfo = new Namespace("loginInfo")
    }

    val providerId = Attribute(ns.loginInfo / "providerId", SchemaType.string, Cardinality.one).withDoc("provider id")
    val providerKey = Attribute(ns.loginInfo / "providerKey", SchemaType.string, Cardinality.one).withDoc("provider key")

    val passwordInfo = Attribute(ns.loginInfo / "passwordInfo", SchemaType.ref, Cardinality.one).withIsComponent(true).withDoc("password info")
    val oauth1Info = Attribute(ns.loginInfo / "oauth1Info", SchemaType.ref, Cardinality.one).withIsComponent(true).withDoc("oauth1 info")
    val oauth2Info = Attribute(ns.loginInfo / "oauth2Info", SchemaType.ref, Cardinality.one).withIsComponent(true).withDoc("oauth2 info")

    val schema = Seq(
      providerId, providerKey,
      passwordInfo, oauth1Info
    )

  }

  implicit val reader: EntityReader[LoginInfo] = (
    Schema.providerId.read[String] and
    Schema.providerKey.read[String]
  )(LoginInfo.apply _)

  implicit val writer: PartialAddEntityWriter[LoginInfo] = (
    Schema.providerId.write[String] and
    Schema.providerKey.write[String]
  )(unlift(LoginInfo.unapply))

  def find(loginInfo: LoginInfo)(implicit conn: Connection): Option[Long] = {
    val query = Query(
      """
    [
      :find ?l
      :in $ ?providerId ?providerKey
      :where
        [?l :loginInfo/providerId ?providerId]
        [?l :loginInfo/providerKey ?providerKey]
    ]
      """)

    LoginInfoImpl.headOptionWithId(Datomic.q(query, Datomic.database, loginInfo.providerID, loginInfo.providerKey)).map(_._1)

  }

  def remove(loginInfo: LoginInfo)(implicit conn: Connection): Unit = find(loginInfo).map(remove)

  def remove(id: Long)(implicit conn: Connection): Unit = LoginInfoImpl.retractEntity(id)

}

// create table "passwordinfo" ("hasher" VARCHAR NOT NULL,"password" VARCHAR NOT NULL,"salt" VARCHAR,"loginInfoId" BIGINT NOT NULL);
// hasher: String, password: String, salt: Option[String] = None

// create table "oauth1info" ("id" BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,"token" VARCHAR NOT NULL,"secret" VARCHAR NOT NULL,"loginInfoId" BIGINT NOT NULL);
object OAuth1InfoImpl extends DB[OAuth1Info] {

  object Schema {

    object ns {
      val oauth1Info = new Namespace("oauth1Info")
    }

    val token = Attribute(ns.oauth1Info / "token", SchemaType.string, Cardinality.one).withDoc("hasher")
    val secret = Attribute(ns.oauth1Info / "secret", SchemaType.string, Cardinality.one).withDoc("password")

    val schema = Seq(
      token, secret
    )

  }

  implicit val reader: EntityReader[OAuth1Info] = (
    Schema.token.read[String] and
    Schema.token.read[String]
  )(OAuth1Info.apply _)

  implicit val writer: PartialAddEntityWriter[OAuth1Info] = (
    Schema.token.write[String] and
    Schema.token.write[String]
  )(unlift(OAuth1Info.unapply))

  def find(loginInfo: LoginInfo)(implicit conn: Connection): Option[OAuth1Info] = {
    val query = Query(
      """
    [
      :find ?e
      :in $ ?providerId ?providerKey
      :where
        [?l :loginInfo/providerId ?providerId]
        [?l :loginInfo/providerKey ?providerKey]
        [?l :loginInfo/oAuth1Info ?e]
    ]
      """)

    DB.headOption(Datomic.q(query, Datomic.database, loginInfo.providerID, loginInfo.providerKey), Datomic.database())

  }

}

// create table "oauth2info" ("id" BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,"accesstoken" VARCHAR NOT NULL,"tokentype" VARCHAR,"expiresin" INTEGER,"refreshtoken" VARCHAR,"logininfoid" BIGINT NOT NULL);
/*
 accessToken: String,
  tokenType: Option[String] = None,
  expiresIn: Option[Int] = None,
  refreshToken: Option[String] = None,
  params: Option[Map[String, String]] = None
 */

object OAuth2InfoImpl extends DB[OAuth2Info] {

  object Schema {

    object ns {
      val oauth2Info = new Namespace("oauth2Info")
    }

    val accessToken = Attribute(ns.oauth2Info / "accesstoken", SchemaType.string, Cardinality.one).withDoc("The access token")
    val tokenType = Attribute(ns.oauth2Info / "tokentype", SchemaType.string, Cardinality.one).withDoc("The token type")
    val expiresIn = Attribute(ns.oauth2Info / "expiresIn", SchemaType.long, Cardinality.one).withDoc("The number of seconds before the token expires")
    val refreshToken = Attribute(ns.oauth2Info / "refreshToken", SchemaType.string, Cardinality.one).withDoc("The refresh token.")
    val params = Attribute(ns.oauth2Info / "params", SchemaType.string, Cardinality.one).withDoc("Additional params transported in conjunction with the token")

    val schema = Seq(
      accessToken, tokenType, expiresIn, refreshToken, params
    )

  }

  def mapToString(mapOpt: Option[Map[String, String]]): Option[String] = None

  def stringToMap(string: String): Option[Map[String, String]] = None

  implicit val reader: EntityReader[OAuth2Info] = (
    Schema.accessToken.read[String] and
    Schema.tokenType.readOpt[String] and
    Schema.expiresIn.readOpt[Int] and
    Schema.refreshToken.readOpt[String] and
    Schema.params.readOrElse[String]("").map(stringToMap)
  )(OAuth2Info.apply _)

  implicit val writer: PartialAddEntityWriter[OAuth2Info] = (
    Schema.accessToken.write[String] and
    Schema.tokenType.writeOpt[String] and
    Schema.expiresIn.writeOpt[Int] and
    Schema.refreshToken.writeOpt[String] and
    Schema.params.writeOpt[String].contramap(mapToString)
  )(unlift(OAuth2Info.unapply))

  def find(loginInfo: LoginInfo)(implicit conn: Connection): Option[OAuth2Info] = {
    val query = Query(
      """
    [
      :find ?e
      :in $ ?providerId ?providerKey
      :where
        [?l :loginInfo/providerId ?providerId]
        [?l :loginInfo/providerKey ?providerKey]
        [?l :loginInfo/oAuth2Info ?e]
    ]
      """)

    DB.headOption(Datomic.q(query, Datomic.database, loginInfo.providerID, loginInfo.providerKey), Datomic.database())

  }

}
